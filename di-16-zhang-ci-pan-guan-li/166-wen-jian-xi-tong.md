#### 1、文件系统的介绍

系统分区完成后，将要将分区格式化文件系统（文件系统是个管理软件，存到磁盘分区的某个位置，文件系统不是整个分区）但是文件系统上的数据是在这个分区上的，所以说文件系统是一个管理软件。

文件系统把磁盘分为两片：元数据存储区**\(metadata\)**（inode位图、块位图、inode条目等等）、数据存储区（**数据存储区**又分为多个逻辑存储单元叫做磁盘块（是逻辑概念））

任何文件系统中的数据分为数据和元数据\(metadata\)。数据是指普通文件中的实际数据，而元数据指用来描述一个文件的特征的系统数据，诸如访问权限、文件拥有者以及文件数据块的分布信息\(inode...\)等等。但是元数据中★不包含文件名**★文件名存放在磁盘块上的**。

#### 2、文件系统层次分析

由上而下主要分为用户层、VFS层、文件系统层、缓存层、块设备层、磁盘驱动层、磁盘物理层

用户层：最上面用户层就是我们日常使用的各种程序，需要的接口主要是文件的创建、删除、打开、关闭、写、读等。

VFS层：我们知道Linux分为用户态和内核态，用户态请求硬件资源需要调用System Call通过内核态去实现。用户的这些文件相关操作都有对应的System Call函数接口，接口调用 VFS对应的函数。

文件系统层：不同的文件系统实现了VFS的这些函数，通过指针注册到VFS里面。所以，用户的操作通过VFS转到各种文件系统。文件系统把文件读写命令转化为对磁盘LBA的操作，起了一个翻译和磁盘管理的作用。

缓存层：文件系统底下有缓存，Page Cache，加速性能。对磁盘LBA的读写数据缓存到这里。

块设备层：块设备接口Block Device是用来访问磁盘LBA的层级，读写命令组合之后插入到命令队列，磁盘的驱动从队列读命令执行。Linux设计了电梯算法等对很多LBA的读写进行优化排序，尽量把连续地址放在一起。

磁盘驱动层：磁盘的驱动程序把对LBA的读写命令转化为各自的协议，比如变成ATA命令，SCSI命令，或者是自己硬件可以识别的自定义命令，发送给磁盘控制器。Host Based SSD甚至在块设备层和磁盘驱动层实现了FTL，变成对Flash芯片的操作。

磁盘物理层：读写物理数据到磁盘介质。

![](/assets/23-26.png)

#### 3、文件系统结构与工作原理（主要以ext4为例）

我们都知道，windows文件系统主要有fat、ntfs等，而linux文件系统则种类多的很，主要有VFS做了一个软件抽象层，

向上提供文件操作接口，向下提供标准接口供不同文件系统对接，下面主要就以EXT4文件系统为例，讲解下文件系统结构与工作原理：

![](/assets/23-27.png)

![](/assets/23-28.png)

上面两个图大体呈现了ext4文件系统的结构，从中也相信能够初步的领悟到文件系统读写的逻辑过程。下面对上图里边的构成元素做个简单的讲解：

引导块：为磁盘分区的第一个块，记录文件系统分区的一些信息，，引导加载当前分区的程序和数据被保存在这个块中。一般占用2kB，

1）超级块：

超级块用于存储文件系统全局的配置参数\(譬如：块大小，总的块数和inode数\)和动态信息\(譬如：当前空闲块数和inode数\)，其处于文件系统开始位置的1k处，所占大小为1k。为了系统的健壮性，最初每个块组都有超级块和组描述符表\(以下将用GDT\)的一个拷贝，但是当文件系统很大时，这样浪费了很多块\(尤其是GDT占用的块多\)，后来采用了一种稀疏的方式来存储这些拷贝，只有块组号是3, 5 ,7的幂的块组\(譬如说1,3,5,7,9,25,49…\)才备份这个拷贝。通常情况下，只有主拷贝\(第0块块组\)的超级块信息被文件系统使用，其它拷贝只有在主拷贝被破坏的情况下才使用。

2）块组描述符：

GDT用于存储块组描述符，其占用一个或者多个数据块，具体取决于文件系统的大小。它主要包含块位图，inode位图和inode表位置，当前空闲块数，inode数以及使用的目录数\(用于平衡各个块组目录数\)，具体定义可以参见ext3\_fs.h文件中struct ext3\_group\_desc。每个块组都对应这样一个描述符，目前该结构占用32个字节，因此对于块大小为4k的文件系统来说，每个块可以存储128个块组描述符。由于GDT对于定位文件系统的元数据非常重要，因此和超级块一样，也对其进行了备份。GDT在每个块组\(如果有备份\)中内容都是一样的，其所占块数也是相同的。从上面的介绍可以看出块组中的元数据譬如块位图，inode位图,inode表其位置不是固定的，当然默认情况下，文件系统在创建时其位置在每个块组中都是一样的，如图2所示\(假设按照稀疏方式存储，且n不是3,5,7的幂\)

3）块组：

每个块组包含一个块位图块，一个 inode 位图块，一个或多个块用于描述 inode 表和用于存储文件数据的数据块，除此之外，还有可能包含超级块和所有块组描述符表\(取决于块组号和文件系统创建时使用的参数\)。下面将对这些元数据作一些简要介绍。

4）块位图：

块位图用于描述该块组所管理的块的分配状态。如果某个块对应的位未置位，那么代表该块未分配，可以用于存储数据；否则，代表该块已经用于存储数据或者该块不能够使用\(譬如该块物理上不存在\)。由于块位图仅占一个块，因此这也就决定了块组的大小。

5）Inode位图：

Inode位图用于描述该块组所管理的inode的分配状态。我们知道inode是用于描述文件的元数据，每个inode对应文件系统中唯一的一个号，如果inode位图中相应位置位，那么代表该inode已经分配出去；否则可以使用。由于其仅占用一个块，因此这也限制了一个块组中所能够使用的最大inode数量。

6）Inode表：

Inode表用于存储inode信息。它占用一个或多个块\(为了有效的利用空间，多个inode存储在一个块中\)，其大小取决于文件系统创建时的参数，由于inode位图的限制，决定了其最大所占用的空间。

以上这几个构成元素所处的磁盘块成为文件系统的元数据块，剩余的部分则用来存储真正的文件内容，称为数据块，而数据块其实也包含数据和目录。

了解了文件系统的结构后，接下来我们来看看操作系统是如何读取一个文件的：

![](/assets/23-29.png)

大体过程如下：

1）根据文件所在目录的inode信息，找到目录文件对应数据块

2）根据文件名从数据块中找到对应的inode节点信息

3）从文件inode节点信息中找到文件内容所在数据块块号

4）读取数据块内容

到这里，相信很多人会有一个疑问，我们知道一个文件只有一个Inode节点来存放它的属性信息，那么你可能会想如果一个大文件，那它的block一定是多个的，且可能不连续的，那么inode怎么来表示呢,下面的图告诉你答案:

![](/assets/23-30.png)

也就是说，如果文件内容太大，对应数据块数量过多，inode节点本身提供的存储空间不够，会使用其他的间接数据块来存储数据块位置信息，最多可以有三级寻址结构。

到这里，应该都已经非常清楚文件读取的过程了，那么下面再抛出两个疑问：

1）文件的拷贝、剪切的底层过程是怎样的？

2）软连接和硬连接分别是如何实现的？

下面来结合stat命令动手操作一下，便知真相：

![](/assets/23-31.png)

1）拷贝文件：创建一个新的inode节点，并且拷贝数据块内容

![](/assets/23-32.png)

2）剪切文件：同个分区里边mv，inode节点不变，只是更新目录文件对应数据块里边的文件名和inode对应关系；跨分区mv，则跟拷贝一个道理，需要创建新的inode，因为inode节点不同分区是不能共享的。

![](/assets/23-33.png)

3）软连接：创建软连接会创建一个新的inode节点，其对应数据块内容存储所链接的文件名信息，这样原文件即便删除了，重新建立一个同名的文件，软连接依然能够生效。

![](/assets/23-34.png)

4\)硬链接：创建硬链接，并不会新建inode节点，只是links加1，还有再目录文件对应数据块上增加一条文件名和inode对应关系记录；只有将硬链接和原文件都删除之后，文件才会真正删除，即links为0才真正删除。

#### 练习题：

1、什么是文件系统

2、文件系统结构与工作原理

